// To parse this JSON data, do
//
//     final SearchModel = SearchModelFromJson(jsonString);

import 'dart:convert';

import 'package:prixs_flutter_test/features/list_books/domain/entities/seach_obj.dart';

class SearchModel {
  SearchModel({
    required this.numFound,
    required this.start,
    required this.numFoundExact,
    required this.docs,
  });

  final int numFound;
  final int start;
  final bool numFoundExact;
  final List<DocModel> docs;

  factory SearchModel.fromRawJson(String str) => SearchModel.fromJson(json.decode(str));

  factory SearchModel.fromJson(Map<String, dynamic> json) => SearchModel(
        numFound: json["numFound"],
        start: json["start"],
        numFoundExact: json["numFoundExact"],
        docs: List<DocModel>.from(json["docs"].map((x) => DocModel.fromJson(x))),
      );
}

class DocModel extends Doc {
  DocModel({
    required key,
    required type,
    required seed,
    required title,
    required titleSuggest,
    required editionCount,
    required editionKey,
    required publishDate,
    required publishYear,
    required firstPublishYear,
    required numberOfPagesMedian,
    required lccn,
    required publishPlace,
    required oclc,
    required contributor,
    required lcc,
    required ddc,
    required isbn,
    required lastModifiedI,
    required ebookCountI,
    required hasFulltext,
    required publicScanB,
    required ia,
    required iaCollectionS,
    required lendingEditionS,
    required lendingIdentifierS,
    required printdisabledS,
    required coverEditionKey,
    required coverI,
    required publisher,
    required language,
    required authorKey,
    required authorName,
    required authorAlternativeName,
    required person,
    required place,
    required subject,
    required time,
    required idAlibrisId,
    required idAmazon,
    required idCanadianNationalLibraryArchive,
    required idDepsitoLegal,
    required idGoodreads,
    required idGoogle,
    required idLibrarything,
    required idOverdrive,
    required idPaperbackSwap,
    required idWikidata,
    required iaLoadedId,
    required iaBoxId,
    required publisherFacet,
    required personKey,
    required placeKey,
    required timeFacet,
    required personFacet,
    required subjectFacet,
    required version,
    required placeFacet,
    required lccSort,
    required authorFacet,
    required subjectKey,
    required ddcSort,
    required timeKey,
  }) : super(
          key: key,
          type: type,
          seed: seed,
          title: title,
          titleSuggest: titleSuggest,
          editionCount: editionCount,
          editionKey: editionKey,
          publishDate: publishDate,
          publishYear: publishYear,
          firstPublishYear: firstPublishYear,
          numberOfPagesMedian: numberOfPagesMedian,
          lccn: lccn,
          publishPlace: publishPlace,
          oclc: oclc,
          contributor: contributor,
          lcc: lcc,
          ddc: ddc,
          isbn: isbn,
          lastModifiedI: lastModifiedI,
          ebookCountI: ebookCountI,
          hasFulltext: hasFulltext,
          publicScanB: publicScanB,
          ia: ia,
          iaCollectionS: iaCollectionS,
          lendingEditionS: lendingEditionS,
          lendingIdentifierS: lendingIdentifierS,
          printdisabledS: printdisabledS,
          coverEditionKey: coverEditionKey,
          coverI: coverI,
          publisher: publisher,
          language: language,
          authorKey: authorKey,
          authorName: authorName,
          authorAlternativeName: authorAlternativeName,
          person: person,
          place: place,
          subject: subject,
          time: time,
          idAlibrisId: idAlibrisId,
          idAmazon: idAmazon,
          idCanadianNationalLibraryArchive: idCanadianNationalLibraryArchive,
          idDepsitoLegal: idDepsitoLegal,
          idGoodreads: idGoodreads,
          idGoogle: idGoogle,
          idLibrarything: idLibrarything,
          idOverdrive: idOverdrive,
          idPaperbackSwap: idPaperbackSwap,
          idWikidata: idWikidata,
          iaLoadedId: iaLoadedId,
          iaBoxId: iaBoxId,
          publisherFacet: publisherFacet,
          personKey: personKey,
          placeKey: placeKey,
          timeFacet: timeFacet,
          personFacet: personFacet,
          subjectFacet: subjectFacet,
          version: version,
          placeFacet: placeFacet,
          lccSort: lccSort,
          authorFacet: authorFacet,
          subjectKey: subjectKey,
          ddcSort: ddcSort,
          timeKey: timeKey,
        );

  factory DocModel.fromRawJson(String str) => DocModel.fromJson(json.decode(str));

  factory DocModel.fromJson(Map<String, dynamic> json) => DocModel(
        key: json["key"],
        type: json["type"],
        seed: json["seed"] == null ? null : List<String>.from(json["seed"].map((x) => x)),
        title: json["title"],
        titleSuggest: json["title_suggest"],
        editionCount: json["edition_count"],
        editionKey: json["edition_key"] == null ? null : List<String>.from(json["edition_key"].map((x) => x)),
        publishDate: json["publish_date"] == null ? null : List<String>.from(json["publish_date"].map((x) => x)),
        publishYear: json["publish_year"] == null ? null : List<int>.from(json["publish_year"].map((x) => x)),
        firstPublishYear: json["first_publish_year"],
        numberOfPagesMedian: json["number_of_pages_median"],
        lccn: json["lccn"] == null ? null : List<String>.from(json["lccn"].map((x) => x)),
        publishPlace: json["publish_place"] == null ? null : List<String>.from(json["publish_place"].map((x) => x)),
        oclc: json["oclc"] == null ? null : List<String>.from(json["oclc"].map((x) => x)),
        contributor: json["contributor"] == null ? null : List<String>.from(json["contributor"].map((x) => x)),
        lcc: json["lcc"] == null ? null : List<String>.from(json["lcc"].map((x) => x)),
        ddc: json["ddc"] == null ? null : List<String>.from(json["ddc"].map((x) => x)),
        isbn: json["isbn"] == null ? null : List<String>.from(json["isbn"].map((x) => x)),
        lastModifiedI: json["last_modified_i"],
        ebookCountI: json["ebook_count_i"],
        hasFulltext: json["has_fulltext"],
        publicScanB: json["public_scan_b"],
        ia: json["ia"] == null ? null : List<String>.from(json["ia"].map((x) => x)),
        iaCollectionS: json["ia_collection_s"],
        lendingEditionS: json["lending_edition_s"],
        lendingIdentifierS: json["lending_identifier_s"],
        printdisabledS: json["printdisabled_s"],
        coverEditionKey: json["cover_edition_key"],
        coverI: json["cover_i"],
        publisher: json["publisher"] == null ? null : List<String>.from(json["publisher"].map((x) => x)),
        language: json["language"] == null ? null : List<String>.from(json["language"].map((x) => x)),
        authorKey: json["author_key"] == null ? null : List<String>.from(json["author_key"].map((x) => x)),
        authorName: json["author_name"] == null ? null : List<String>.from(json["author_name"].map((x) => x)),
        authorAlternativeName: json["author_alternative_name"] == null ? null : List<String>.from(json["author_alternative_name"].map((x) => x)),
        person: json["person"] == null ? null : List<String>.from(json["person"].map((x) => x)),
        place: json["place"] == null ? null : List<String>.from(json["place"].map((x) => x)),
        subject: json["subject"] == null ? null : List<String>.from(json["subject"].map((x) => x)),
        time: json["time"] == null ? null : List<String>.from(json["time"].map((x) => x)),
        idAlibrisId: json["id_alibris_id"] == null ? null : List<String>.from(json["id_alibris_id"].map((x) => x)),
        idAmazon: json["id_amazon"] == null ? null : List<String>.from(json["id_amazon"].map((x) => x)),
        idCanadianNationalLibraryArchive: json["id_canadian_national_library_archive"] == null ? null : List<String>.from(json["id_canadian_national_library_archive"].map((x) => x)),
        idDepsitoLegal: json["id_depósito_legal"] == null ? null : List<String>.from(json["id_depósito_legal"].map((x) => x)),
        idGoodreads: json["id_goodreads"] == null ? null : List<String>.from(json["id_goodreads"].map((x) => x)),
        idGoogle: json["id_google"] == null ? null : List<String>.from(json["id_google"].map((x) => x)),
        idLibrarything: json["id_librarything"] == null ? null : List<String>.from(json["id_librarything"].map((x) => x)),
        idOverdrive: json["id_overdrive"] == null ? null : List<String>.from(json["id_overdrive"].map((x) => x)),
        idPaperbackSwap: json["id_paperback_swap"] == null ? null : List<String>.from(json["id_paperback_swap"].map((x) => x)),
        idWikidata: json["id_wikidata"] == null ? null : List<String>.from(json["id_wikidata"].map((x) => x)),
        iaLoadedId: json["ia_loaded_id"] == null ? null : List<String>.from(json["ia_loaded_id"].map((x) => x)),
        iaBoxId: json["ia_box_id"] == null ? null : List<String>.from(json["ia_box_id"].map((x) => x)),
        publisherFacet: json["publisher_facet"] == null ? null : List<String>.from(json["publisher_facet"].map((x) => x)),
        personKey: json["person_key"] == null ? null : List<String>.from(json["person_key"].map((x) => x)),
        placeKey: json["place_key"] == null ? null : List<String>.from(json["place_key"].map((x) => x)),
        timeFacet: json["time_facet"] == null ? null : List<String>.from(json["time_facet"].map((x) => x)),
        personFacet: json["person_facet"] == null ? null : List<String>.from(json["person_facet"].map((x) => x)),
        subjectFacet: json["subject_facet"] == null ? null : List<String>.from(json["subject_facet"].map((x) => x)),
        version: json["_version_"] == null ? null : json["_version_"].toDouble(),
        placeFacet: json["place_facet"] == null ? null : List<String>.from(json["place_facet"].map((x) => x)),
        lccSort: json["lcc_sort"],
        authorFacet: json["author_facet"] == null ? null : List<String>.from(json["author_facet"].map((x) => x)),
        subjectKey: json["subject_key"] == null ? null : List<String>.from(json["subject_key"].map((x) => x)),
        ddcSort: json["ddc_sort"],
        timeKey: json["time_key"] == null ? null : List<String>.from(json["time_key"].map((x) => x)),
      );
}
